################################################################################
# Copyright (c) 2021-2022 Vladislav Trifochkin
#
# This file is part of `portable-target`.
#
# Changelog:
#      2022.01.12 Initial version.
###############################################################################
cmake_minimum_required(VERSION 3.11)
include(${CMAKE_CURRENT_LIST_DIR}/../Functions.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/../3rdparty/cmrc/CMakeRC.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/add_library.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/link_libraries.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/sources.cmake)

#
# Usage:
#
# portable_target_icons(<target>
#   [NAMESPACE ns]
#   filename1|alias1[|alias2...] ...)
#
# NAMESPACE ns      C++ namespace (default is `icons`)
#
function (portable_target_icons TARGET)
    set(boolparm)
    set(singleparm NAMESPACE)
    set(multiparm)

    cmake_parse_arguments(_arg "${boolparm}" "${singleparm}" "${multiparm}" ${ARGN})

    if (NOT _arg_NAMESPACE)
        set(_arg_NAMESPACE icons)
    endif()

    _portable_target_trace(${TARGET} "Icons namespace: [${_arg_NAMESPACE}]")

    if (_arg_UNPARSED_ARGUMENTS)
        set(_output_filename ${CMAKE_CURRENT_BINARY_DIR}/${TARGET}.cpp)
        _portable_target_trace(${TARGET} "Generating main source: [${_output_filename}]")

        string(TIMESTAMP _generation_time UTC)

        file(WRITE ${_output_filename}
            "//////////////////////////////////////////////////////////////////////////////\n")
        file(APPEND ${_output_filename}
            "/// AUTOMATICALLY GENERATED BY portable_target AT ${_generation_time} UTC ///\n")
        file(APPEND ${_output_filename}
            "//////////////////////////////////////////////////////////////////////////////\n")

        file(APPEND ${_output_filename} [=[
#include <cmrc/cmrc.hpp>
#include <iterator>
#include <map>
#include <cstring>
#include <cassert>

]=])

        file(APPEND ${_output_filename}
            "CMRC_DECLARE(${_arg_NAMESPACE}); // <= resource library's namespace\n")

        file(APPEND ${_output_filename} [=[

namespace __cmrc = cmrc::icons;

static char const * EMPTY_SHORTCODE_ERROR    = "empty shortcode";
static char const * BAD_SHORTCODE_ERROR      = "bad shortcode, must be enclosed between colons (e.g. \":shorcode:\"";
static char const * RESOURCE_NOT_FOUND_ERROR = "resource not found";
static char const * UNEXPECTED_ERROR         = "unexpected error";
static char const * OUT_OF_BOUNDS_ERROR      = "shortcode index is out of bounds";

struct cstr_comparator
{
   bool operator () (char const * a, char const * b) const
   {
      return std::strcmp(a, b) < 0;
   }
};

using bundle_map_type = std::map<char const *, char const *, cstr_comparator>;

static bundle_map_type const BUNDLE = {
]=])

        set(_cmrc_sources)
        set(_indent "      ")

        foreach (_orig_record ${_arg_UNPARSED_ARGUMENTS})
            string(REPLACE "|" ";" _record ${_orig_record})
            list(LENGTH _record _count)

            if (${_count} LESS 2)
                _portable_target_error(${TARGET} "Incomplete record at: [${_orig_record}]")
            endif()

            list(GET _record 0 _filename)
            list(REMOVE_AT _record 0)
            string(STRIP ${_filename} _filename)
            list(APPEND _cmrc_sources ${_filename}) # Add source for CMRC

            while (_record)
                list(GET _record 0 _alias)
                list(REMOVE_AT _record 0)

                file(APPEND ${_output_filename}
                    "${_indent}{\"${_alias}\", \"${_filename}\"}\n")

                set(_indent "    , ")
            endwhile()
        endforeach()

        file(APPEND ${_output_filename} [=[
};

inline char const * filename_by_shortcode (char const * shortcode)
{
    auto it = BUNDLE.find(shortcode);
    return it != BUNDLE.end() ? it->second : nullptr;
}

extern "C" {

int total_shortcodes ()
{
    return static_cast<int>(BUNDLE.size());
}

char const * shortcode_at (int index)
{
    if (index < 0 || index >= BUNDLE.size())
        return nullptr;

    auto it = BUNDLE.begin();
    std::advance(it, index);
    return it->first;
}

bool get_icon (std::string const & shortcode
    , char const ** begin
    , std::size_t * size
    , const char ** errstr)
{
    assert(begin);
    assert(size);

    if (shortcode.empty()) {
        if (errstr)
            *errstr = EMPTY_SHORTCODE_ERROR;
        return false;
    }

    bool good_format = shortcode[0] == ':'
        && shortcode[shortcode.size() - 1] == ':';

    if (!good_format) {
        if (errstr) {
            *errstr = BAD_SHORTCODE_ERROR;
        }
        return false;
    }

    char const * filename = filename_by_shortcode(shortcode.c_str());

    if (!filename) {
        if (errstr)
            *errstr = RESOURCE_NOT_FOUND_ERROR;
        return false;
    }

    auto fs = __cmrc::get_filesystem();

    try {
        auto rc = fs.open(filename);
        *begin = rc.begin();
        *size = std::distance(rc.begin(), rc.end());
    } catch (std::system_error ex) {
        if (errstr)
            *errstr = RESOURCE_NOT_FOUND_ERROR;

        if (ex.code() == std::errc::no_such_file_or_directory) {
            if (errstr)
                *errstr = RESOURCE_NOT_FOUND_ERROR;
            return false;
        }

        if (errstr)
            *errstr = UNEXPECTED_ERROR;

        return false;
    } catch (...) {
        if (errstr)
            *errstr = UNEXPECTED_ERROR;
    }

    return true;
}

bool get_icon_at (int index
    , char const ** begin
    , std::size_t * size
    , const char ** errstr)
{
    char const * shortcode = shortcode_at(index);

    if (!shortcode) {
        if (errstr)
            *errstr = OUT_OF_BOUNDS_ERROR;
        return false;
    }

    return get_icon(shortcode, begin, size, errstr);
}

} // extern "C"
]=])

        if (_cmrc_sources)
            set(_bundle_target ${TARGET}_${_arg_NAMESPACE})

            cmrc_add_resource_library(${_bundle_target}
                NAMESPACE ${_arg_NAMESPACE}
                ${_cmrc_sources})

            portable_target_add_library(${TARGET})
            portable_target_sources(${TARGET} ${_output_filename} )
            portable_target_link_libraries(${TARGET} PRIVATE ${_bundle_target})

            if (CMAKE_COMPILER_IS_GNUCXX)
                # For link custom shared libraries with static library
                target_compile_options(${_bundle_target} PRIVATE "-fPIC")
            endif()
        endif()

    endif()
endfunction(portable_target_icons)
